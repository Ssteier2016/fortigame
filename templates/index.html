import React, { useState, useEffect, useRef, useCallback } from 'react';
import { Button } from '@/components/ui/button';
import { Mic, Play, StopCircle, Users, Radio, Send, AlertTriangle, XCircle, CheckCircle } from 'lucide-react';
import { Slider } from '@/components/ui/slider';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { cn } from '@/lib/utils';
import { motion, AnimatePresence } from 'framer-motion';

// Mock Web APIs (para demostración en el navegador)
const mockBackground = {
    start: () => console.log('Servicio en segundo plano iniciado'),
    stop: () => console.log('Servicio en segundo plano detenido'),
    on: (event: string, callback: (...args: any[]) => void) => {
        console.log(`Escuchando evento en segundo plano: ${event}`);
        // Almacenar callbacks y simular eventos según sea necesario
        if (event === 'audio') {
            mockBackground.audioCallback = callback;
        }
        if (event === 'message') { // Agregado para simular mensajes de texto
            mockBackground.messageCallback = callback;
        }
    },
    audioCallback: null as ((data: any) => void) | null,
    emitAudio: (data: any) => {
        if (mockBackground.audioCallback) {
            mockBackground.audioCallback(data);
        }
    },
    messageCallback: null as ((data: any) => void) | null, // Agregado para mensajes
    emitMessage: (data: any) => { // Agregado para emitir mensajes
        if (mockBackground.messageCallback) {
            mockBackground.messageCallback(data);
        }
    }
};

const mockRNFS = { //Simula el sistema de archivos
    writeFile: (filepath: string, content: string, encoding: string) => {
        console.log(`Escribiendo en el archivo: ${filepath} con contenido: ${content} y encoding: ${encoding}`);
        return Promise.resolve(true); // Simula escritura exitosa
    },
    readDir: (dirpath: string) => {
        console.log(`Leyendo directorio: ${dirpath}`);
        return Promise.resolve([]); // Simula un directorio vacío
    },
    mkdir: (dirpath: string) => {
        console.log(`Creando directorio: ${dirpath}`);
        return Promise.resolve(true);
    },
    exists: (filepath: string) => {
        console.log(`Verificando existencia del archivo: ${filepath}`);
        return Promise.resolve(false);
    },
    unlink: (filepath: string) => {
        console.log(`Eliminando archivo: ${filepath}`);
        return Promise.resolve(true);
    },
    CachesDirectoryPath: 'mocked/cache/directory', //Simula la ruta del directorio de caché
    DocumentDirectoryPath: 'mocked/documents/directory',
};

const mockSound = {
    play: (filepath: string) => {
        console.log(`Reproduciendo sonido desde: ${filepath}`);
        // Aquí podrías usar el API de Web Audio para realmente reproducir el sonido en el navegador
        // Por simplicidad, solo simulamos la reproducción
        return Promise.resolve();
    },
    stop: () => {
        console.log('Deteniendo sonido');
        return Promise.resolve();
    },
    release: () => {
        console.log('Liberando recursos de sonido');
        return Promise.resolve();
    }
};

const mockAudioRecorder = {
    start: (filepath: string, options: any) => {
        console.log(`Iniciando grabación en: ${filepath} con opciones:`, options);
        mockAudioRecorder.isRecording = true;
        mockAudioRecorder.recordingPath = filepath; //Guarda la ruta del archivo
        return Promise.resolve();
    },
    stop: () => {
        console.log('Deteniendo grabación');
        mockAudioRecorder.isRecording = false;
        // Simula la creación de un archivo de audio y emite el evento 'audio'
        if (mockBackground.audioCallback && mockAudioRecorder.recordingPath) {
            // Simula la codificación del audio y la obtención de la ruta del archivo
            const audioData = {
                uri: mockAudioRecorder.recordingPath, // Usa la ruta guardada
                duration: 2.5, // Simula la duración del audio
                base64: 'base64_encoded_audio_data' // Simula datos de audio codificados en base64
            };
            mockBackground.emitAudio(audioData); // Llama al callback para simular el envío del audio
        }
        return Promise.resolve({ base64: 'mocked_base64_audio_data' }); // Simula los datos de audio
    },
    pause: () => {
        console.log('Pausando grabación');
        return Promise.resolve();
    },
    resume: () => {
        console.log('Reanudando grabación');
        return Promise.resolve();
    },
    isRecording: false,
    recordingPath: '', //Guarda la ruta del archivo de audio
};

const mockNetInfo = {
    fetch: () => {
        console.log('Obteniendo información de la red');
        // Simula estar conectado a una red
        return Promise.resolve({
            isConnected: true,
            type: 'wifi', // Simula conexión WiFi
            details: null,
        });
    },
    addEventListener: (callback: (state: any) => void) => {
        console.log('Escuchando cambios en el estado de la red');
        // Simula un cambio inicial en el estado de la red
        mockNetInfo.currentCallback = callback; //Guarda el callback
        // Llama al callback inmediatamente con un estado de red simulado
        callback({ isConnected: true, type: 'wifi', details: null });

        // Devuelve una función de limpieza para simular la desuscripción
        return () => {
            mockNetInfo.currentCallback = null;
            console.log('Dejando de escuchar cambios en el estado de la red');
        };
    },
    currentCallback: null as ((state: any) => void) | null,
    simulateNetworkChange: (isConnected: boolean, type: string) => {
        if (mockNetInfo.currentCallback) {
            mockNetInfo.currentCallback({ isConnected, type, details: null });
        }
    }
};

const mockAlert = {
    alert: (title: string, message?: string, buttons?: any[]) => {
        console.log(`Alerta: ${title}, Mensaje: ${message}, Botones:`, buttons);
        // Simula la interacción del usuario con la alerta
        if (buttons) {
            const defaultButton = buttons.find(b => b.text === 'OK') || buttons[0]; // Encuentra el OK
            if (defaultButton && defaultButton.onPress) {
                setTimeout(defaultButton.onPress, 0); // Simula un click
            }
        }
    }
};

const mockVibration = {
    vibrate: (pattern: number | number[] | 'long' | 'short') => {
        console.log('Vibrando con patrón:', pattern);
        // Simula la vibración (puedes usar la API de Vibración del navegador si está disponible)
        if ('vibrate' in navigator) {
            if (pattern === 'long') {
                navigator.vibrate(200); // Simula vibración larga
            } else if (pattern === 'short') {
                navigator.vibrate(50); // Simula vibración corta
            } else {
                navigator.vibrate(pattern);
            }
        }
    }
};

const mockAppState = {
    currentState: 'active',
    addEventListener: (type: 'change', handler: (state: string) => void) => {
        console.log(`Escuchando cambios en el estado de la aplicación (${type})`);
        mockAppState.eventHandler = handler;
        // Llama al handler inmediatamente con el estado actual
        handler(mockAppState.currentState);

        return {
            remove: () => {
                mockAppState.eventHandler = null;
                console.log(`Dejando de escuchar cambios en el estado de la aplicación (${type})`);
            }
        };
    },
    eventHandler: null as ((state: string) => void) | null,
    simulateAppStateChange: (newState: string) => {
        mockAppState.currentState = newState;
        if (mockAppState.eventHandler) {
            mockAppState.eventHandler(newState);
        }
    }
};

const mockDeviceEventEmitter = {
    addListener: (event: string, callback: (...args: any[]) => void) => {
        console.log(`Escuchando evento nativo: ${event}`);
        // Almacena los callbacks para simular la emisión de eventos nativos
        if (event === 'proximity') {
            mockDeviceEventEmitter.proximityCallback = callback;
        }
        return {
            remove: () => {
                console.log(`Dejando de escuchar evento nativo: ${event}`);
                if (event === 'proximity') {
                    mockDeviceEventEmitter.proximityCallback = null;
                }
            }
        };
    },
    emit: (event: string, data: any) => {
        console.log(`Emisión de evento nativo: ${event} con datos:`, data);
        if (event === 'proximity' && mockDeviceEventEmitter.proximityCallback) {
            mockDeviceEventEmitter.proximityCallback(data);
        }
    },
    proximityCallback: null as ((data: any) => void) | null,
};

const mockPlatform = {
    OS: 'android', // Simula la plataforma Android
    Version: '12', //Simula la versión de Android
};

const mockPermissions = {
    request: async (permission: string) => {
        console.log(`Solicitando permiso: ${permission}`);
        // Simula la concesión del permiso
        return Promise.resolve('granted');
    },
    check: async (permission: string) => {
        console.log(`Verificando permiso: ${permission}`);
        return Promise.resolve('granted'); //Simula permiso concedido
    }
};

const mockSpeech = {
    startSpeech: (options: any, callback: (result: string) => void) => {
        console.log("Iniciando reconocimiento de voz con opciones:", options);
        mockSpeech.isListening = true;
        mockSpeech.currentCallback = callback;

        //Simula el final del reconocimiento de voz después de un tiempo
        mockSpeech.timeoutId = setTimeout(() => {
            mockSpeech.isListening = false;
            const simulatedResult = "Hola, ¿cómo estás?";  // Simula el resultado
            console.log("Resultado de la transcripción:", simulatedResult);
            callback(simulatedResult); // Llama al callback con el resultado simulado
            mockSpeech.currentCallback = null;
        }, 3000); // Simula 3 segundos de escucha

        return Promise.resolve();
    },
    stopSpeech: () => {
        console.log("Deteniendo reconocimiento de voz");
        mockSpeech.isListening = false;
        clearTimeout(mockSpeech.timeoutId);
        mockSpeech.currentCallback = null;
        return Promise.resolve();
    },
    isListening: false,
    currentCallback: null as ((result: string) => void) | null,
    timeoutId: null as NodeJS.Timeout | null,
};

// Constantes y tipos
const AUDIO_FORMATS = {
    MP3: 'mp3',
    PCM: 'pcm',
};

const SAMPLE_RATES = [8000, 11025, 12000, 16000, 22050, 24000, 32000, 44100, 48000];

// Interfaz para los datos de audio
interface AudioData {
    uri: string;
    duration: number;
    base64?: string;
}

// Interfaz para los mensajes del chat
interface ChatMessage {
    id: string;
    sender: string;
    text: string;
    timestamp: number;
}

// Componente principal de la aplicación
const AndroidWalkieTalkie = () => {
    // Estados
    const [isServiceRunning, setIsServiceRunning] = useState(false);
    const [isRecording, setIsRecording] = useState(false);
    const [audioFormat, setAudioFormat] = useState<keyof typeof AUDIO_FORMATS>(AUDIO_FORMATS.MP3);
    const [sampleRate, setSampleRate] = useState(16000); // Valor por defecto
    const [pttMode, setPttMode] = useState<'hold' | 'toggle'>('hold');  // 'hold' o 'toggle'
    const [proximity, setProximity] = useState<boolean | null>(null); // null: desconocido, true: cerca, false: lejos
    const [outputVolume, setOutputVolume] = useState(1); // 0 a 1
    const [networkInfo, setNetworkInfo] = useState<{ isConnected: boolean; type: string; details: any } | null>(null);
    const [appState, setAppState] = useState<'active' | 'background' | 'inactive'>('active');
    const [messages, setMessages] = useState<ChatMessage[]>([]); // Para el chat global
    const [currentMessage, setCurrentMessage] = useState('');  // Mensaje actual en el input
    const [isListening, setIsListening] = useState(false); // Para el estado de escucha de STT

    // Refs
    const audioPlayer = useRef<HTMLAudioElement | null>(null);
    const recordingTimeoutRef = useRef<NodeJS.Timeout | null>(null);
    const messagesEndRef = useRef<HTMLDivElement>(null); // Ref para el scroll del chat
    const chatInputRef = useRef<HTMLTextAreaElement>(null);

    // Variables para simular la lógica de la app nativa
    let audioFilePath: string; // Variable para almacenar la ruta del archivo de audio
    let userName = "Usuario" + Math.floor(Math.random() * 100); // Simula nombre de usuario

    // Efectos secundarios

    // Inicialización y configuración del servicio en segundo plano
    useEffect(() => {
        // Simula la inicialización del servicio en segundo plano
        mockBackground.start();
        setIsServiceRunning(true);

        // Simula la recepción de eventos de audio desde el servicio en segundo plano
        mockBackground.on('audio', (data: AudioData) => {
            console.log('Audio recibido en la aplicación:', data);
            // Reproducir el audio (simulado)
            playSound(data.uri); // Usa la ruta del archivo
        });

        // Simula la recepción de mensajes de texto
        mockBackground.on('message', (data: ChatMessage) => {
            console.log('Mensaje recibido:', data);
            setMessages(prevMessages => [...prevMessages, data]);
        });

        // Limpieza al desmontar el componente
        return () => {
            mockBackground.stop();
            setIsServiceRunning(false);
            if (recordingTimeoutRef.current) {
                clearTimeout(recordingTimeoutRef.current);
            }
        };
    }, []);

    // Obtener información de la red
    useEffect(() => {
        const fetchNetworkInfo = async () => {
            const info = await mockNetInfo.fetch();
            setNetworkInfo(info);
        };

        fetchNetworkInfo();

        const unsubscribe = mockNetInfo.addEventListener((state) => {
            setNetworkInfo(state);
        });

        return () => {
            unsubscribe();
        };
    }, []);

    // Manejar cambios en el estado de la aplicación
    useEffect(() => {
        const subscription = mockAppState.addEventListener('change', (newState) => {
            setAppState(newState);
            console.log('Estado de la aplicación cambiado a:', newState);
            if (newState === 'background') {
                // Lógica específica para cuando la app pasa a segundo plano
                console.log('La aplicación está en segundo plano');
            } else if (newState === 'active') {
                // Lógica específica para cuando la app vuelve a primer plano
                console.log('La aplicación está en primer plano');
            }
        });

        return () => {
            subscription.remove();
        };
    }, []);

    // Manejar eventos de proximidad
    useEffect(() => {
        const proximityListener = mockDeviceEventEmitter.addListener('proximity', (data: { isNear: boolean }) => {
            setProximity(data.isNear);
            console.log('Sensor de proximidad:', data.isNear ? 'Cerca' : 'Lejos');
            if (data.isNear) {
                // Acciones al detectar proximidad (ej., silenciar audio)
                if (audioPlayer.current) {
                    audioPlayer.current.muted = true;
                }
            } else {
                // Acciones al no detectar proximidad (ej., restaurar volumen)
                if (audioPlayer.current) {
                    audioPlayer.current.muted = false;
                }
            }
        });

        return () => {
            proximityListener.remove();
        };
    }, []);

    // Función para simular la reproducción de sonido
    const playSound = useCallback(async (filePath: string) => {
        try {
            // Detener cualquier sonido anterior
            if (audioPlayer.current) {
                await mockSound.stop();
                await mockSound.release();
                audioPlayer.current = null;
            }

            // Crear un nuevo elemento de audio para la reproducción
            audioPlayer.current = new Audio(filePath); // Usa la ruta directa
            audioPlayer.current.volume = outputVolume;
            await mockSound.play(filePath); //Simula la reproducción

        } catch (error) {
            console.error('Error al reproducir sonido:', error);
            mockAlert.alert('Error', 'No se pudo reproducir el audio.');
        }
    }, [outputVolume]);

    // Función para iniciar la grabación de audio
    const startRecording = async () => {
        try {
            // Solicitar permisos de audio (simulado)
            const audioPermission = await mockPermissions.request('android.permission.RECORD_AUDIO');
            if (audioPermission !== 'granted') {
                mockAlert.alert('Permiso Denegado', 'Se requiere permiso para grabar audio.');
                return;
            }

            // Verificar conexión de red
            if (!networkInfo?.isConnected) {
                mockAlert.alert('Sin Conexión', 'No hay conexión de red disponible.');
                return;
            }

            // Generar un nombre de archivo único (simulado)
            const fileName = `audio-${Date.now()}.${audioFormat.toLowerCase()}`;
            audioFilePath = `${mockRNFS.CachesDirectoryPath}/${fileName}`; // Usa la variable global

            // Iniciar la grabación (simulado)
            await mockAudioRecorder.start(audioFilePath, {
                sampleRate,
                channels: 1, // Mono
                bitsPerSample: 16,
                audioSource: 6, // MediaRecorder.AudioSource.MIC
                outputFormat:
                    audioFormat === AUDIO_FORMATS.MP3
                        ? 1 // MediaRecorder.OutputFormat.MPEG_4
                        : 3, // MediaRecorder.OutputFormat.THREE_GPP
                encoder:
                    audioFormat === AUDIO_FORMATS.MP3
                        ? 4 // MediaRecorder.AudioEncoder.AAC
                        : 2, // MediaRecorder.AudioEncoder.AMR_NB
            });
            setIsRecording(true);
            mockVibration.vibrate('short'); // Vibrar al iniciar la grabación
            console.log('Grabación iniciada en:', audioFilePath);
        } catch (error) {
            console.error('Error al iniciar la grabación:', error);
            mockAlert.alert('Error', 'No se pudo iniciar la grabación.');
            setIsRecording(false);
        }
    };

    // Función para detener la grabación de audio
    const stopRecording = async () => {
        try {
            // Detener la grabación (simulado)
            const audioData = await mockAudioRecorder.stop();
            setIsRecording(false);
            mockVibration.vibrate('short'); // Vibrar al detener la grabación
            console.log('Grabación detenida. Datos de audio:', audioData);
            // Reproducir el audio grabado (simulado)
            playSound(audioFilePath); // Usa la ruta guardada en audioFilePath
        } catch (error) {
            console.error('Error al detener la grabación:', error);
            mockAlert.alert('Error', 'No se pudo detener la grabación.');
        }
    };

    // Función para manejar el evento de pulsar para hablar (PTT)
    const handlePTT = () => {
        if (pttMode === 'hold') {
            // Modo Mantener presionado
            if (isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        } else {
            // Modo Alternar
            if (isRecording) {
                stopRecording();
            } else {
                startRecording();
            }
        }
    };

    // Función para simular el cambio de red
    const simulateNetworkChange = (isConnected: boolean, type: string) => {
        mockNetInfo.simulateNetworkChange(isConnected, type);
    };

    // Función para simular el cambio de estado de la aplicación
    const simulateAppStateChange = (newState: 'active' | 'background' | 'inactive') => {
        mockAppState.simulateAppStateChange(newState);
    };

    // Función para simular la emisión de un evento de proximidad
    const simulateProximityEvent = (isNear: boolean) => {
        mockDeviceEventEmitter.emit('proximity', { isNear });
    };

    // Función para enviar mensajes de texto al chat
    const sendMessage = () => {
        if (currentMessage.trim()) {
            const newMessage: ChatMessage = {
                id: crypto.randomUUID(), // Simula un ID único
                sender: userName, // Usa el nombre de usuario simulado
                text: currentMessage,
                timestamp: Date.now(),
            };
            setMessages(prevMessages => [...prevMessages, newMessage]);
            mockBackground.emitMessage(newMessage); // Simula el envío al servicio en segundo plano
            setCurrentMessage(''); // Limpia el input
            if (chatInputRef.current) {
                chatInputRef.current.style.height = 'auto'; // Reset textarea height
            }
        }
    };

    // Función para formatear la hora del mensaje
    const formatTimestamp = (timestamp: number) => {
        const date = new Date(timestamp);
        return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    };

    // Efecto para hacer scroll al final del chat cuando hay nuevos mensajes
    useEffect(() => {
        messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });
    }, [messages]);

    // Función para iniciar el reconocimiento de voz
    const startSpeechRecognition = async () => {
        try {
            setIsListening(true);
            await mockSpeech.startSpeech({ language: 'es-ES' }, (result) => {
                setCurrentMessage(result);
                setIsListening(false);
            });
        } catch (error) {
            console.error("Error al iniciar el reconocimiento de voz:", error);
            mockAlert.alert("Error", "No se pudo iniciar el reconocimiento de voz.");
            setIsListening(false);
        }
    };

    // Función para detener el reconocimiento de voz
    const stopSpeechRecognition = () => {
        mockSpeech.stopSpeech();
        setIsListening(false);
    };

    // Función para alternar el reconocimiento de voz
    const toggleSpeechRecognition = () => {
        if (isListening) {
            stopSpeechRecognition();
        } else {
            startSpeechRecognition();
        }
    };

    // Efecto para auto-ajustar la altura del textarea
    useEffect(() => {
        const textarea = chatInputRef.current;
        if (textarea) {
            textarea.style.height = 'auto';
            textarea.style.height = `${textarea.scrollHeight}px`;
        }
    }, [currentMessage]);

    return (
        <div className="min-h-screen bg-gray-900 text-white flex flex-col">
            {/* Encabezado */}
            <header className="bg-gray-800 p-4 flex items-center justify-between border-b border-gray-700">
                <div className="flex items-center gap-2">
                    <Radio className="w-6 h-6 text-red-500" />
                    <h1 className="text-xl font-bold">Android Walkie Talkie</h1>
                </div>
                <div className="flex items-center gap-4">
                    <span className="text-sm text-gray-400">
                        {isServiceRunning ? 'Servicio Activo' : 'Servicio Inactivo'}
                    </span>
                    <Users className="w-6 h-6 text-gray-400" />
                </div>
            </header>

            {/* Contenido principal */}
            <main className="flex-1 p-6 space-y-8">
                {/* Estado de la Conexión */}
                <div className="bg-gray-800 p-4 rounded-lg border border-gray-700 flex items-center justify-between">
                    <div className="flex items-center gap-4">
                        <span className="text-lg font-semibold">Usuarios Conectados:</span>
                        {networkInfo ? (
                            <span className={cn(
                                "text-lg",
                                networkInfo.isConnected ? "text-green-500" : "text-red-500"
                            )}>
                                {networkInfo.isConnected ? 'Conectados' : 'Desconectados'} ({networkInfo.type})
                            </span>
                        ) : (
                            <span className="text-gray-400">Cargando...</span>
                        )}
                    </div>
                    <div className="flex gap-2">
                        <Button
                            variant="outline"
                            size="sm"
                            onClick={() => simulateNetworkChange(true, 'wifi')}
                            className="bg-green-500/20 text-green-400 hover:bg-green-500/30 hover:text-green-300 border-green-500/30"
                        >
                            Simular Wifi
                        </Button>
                        <Button
                            variant="outline"
                            size="sm"
                            onClick={() => simulateNetworkChange(false, 'none')}
                            className="bg-red-500/20 text-red-400 hover:bg-red-500/30 hover:text-red-300 border-red-500/30"
                        >
                            Simular Sin Conexión
                        </Button>
                    </div>
                </div>

                {/* Control de Pulsar para Hablar (PTT) */}
                <div className="bg-gray-800 p-6 rounded-lg border border-gray-700 flex flex-col items-center">
                    <h2 className="text-2xl font-bold mb-6">Pulsar para Hablar (PTT)</h2>
                    <motion.button
                        whileTap={{ scale: isRecording ? 0.9 : 1.1 }}
                        onMouseDown={handlePTT}
                        onMouseUp={handlePTT}
                        onTouchStart={handlePTT} // Para dispositivos táctiles
                        onTouchEnd={handlePTT}
                        className={cn(
                            "w-32 h-32 rounded-full flex items-center justify-center transition-all duration-300",
                            isRecording
                                ? "bg-red-600 text-white"
                                : "bg-green-600 text-white hover:bg-green-700"
                        )}
                        style={{
                            boxShadow: isRecording
                                ? '0 0 20px rgba(255, 0, 0, 0.7)' // Resplandor rojo al grabar
                                : '0 0 20px rgba(0, 255, 0, 0.7)', // Resplandor verde al pulsar
                        }}
                        aria-label="Pulsar para Hablar"
                    >
                        {isRecording ? (
                            <StopCircle className="w-12 h-12" />
                        ) : (
                            <Mic className="w-12 h-12" />
                        )}
                    </motion.button>
                    <div className="mt-4 flex items-center gap-4">
                        <span className="text-lg">Modo PTT:</span>
                        <Button
                            variant={pttMode === 'hold' ? 'default' : 'outline'}
                            onClick={() => setPttMode('hold')}
                            className={cn(
                                pttMode === 'hold'
                                    ? "bg-blue-500 text-white"
                                    : "text-gray-400 hover:text-white hover:bg-gray-700"
                            )}
                        >
                            Mantener
                        </Button>
                        <Button
                            variant={pttMode === 'toggle' ? 'default' : 'outline'}
                            onClick={() => setPttMode('toggle')}
                            className={cn(
                                pttMode === 'toggle'
                                    ? "bg-blue-500 text-white"
                                    : "text-gray-400 hover:text-white hover:bg-gray-700"
                            )}
                        >
                            Alternar
                        </Button>
                    </div>
                    <div className="mt-6 w-full">
                        <span className="text-lg block mb-2">Volumen de Salida: {Math.round(outputVolume * 100)}%</span>
                        <Slider
                            min={0}
                            max={1}
                            step={0.01}
                            value={[outputVolume]}
                            onValueChange={(value) => setOutputVolume(value[0])}
                            className="w-full"
                        />
                    </div>
                </div>

                {/* Chat Global */}
                <div className="bg-gray-800 p-6 rounded-lg border border-gray-700 flex flex-col">
                    <h2 className="text-2xl font-bold mb-4">Chat Global</h2>
                    <div className="flex-1 overflow-y-auto space-y-2 max-h-[200px] pr-2">
                        {messages.map((msg) => (
                            <div
                                key={msg.id}
                                className={cn(
                                    "p-2 rounded-lg",
                                    msg.sender === userName ? "bg-blue-500/20 text-blue-300 ml-auto w-fit" : "bg-gray-700 text-gray-300 mr-auto w-fit"
                                )}
                            >
                                <div className="flex items-end gap-1">
                                  <span className="font-semibold text-sm">{msg.sender}:</span>
                                  <span className="text-sm">{msg.text}</span>
                                </div>
                                <span className="block text-xs text-right opacity-70">
                                    {formatTimestamp(msg.timestamp)}
                                </span>
                            </div>
                        ))}
                        <div ref={messagesEndRef} /> {/* Ref para el scroll */}
                    </div>
                    <div className="mt-4 flex items-center gap-2">
                        <Textarea
                            ref={chatInputRef}
                            value={currentMessage}
                            onChange={(e) => setCurrentMessage(e.target.value)}
                            placeholder="Escribe tu mensaje..."
                            className="flex-1 bg-gray-700 text-white rounded-md p-3 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500 resize-none"
                            onKeyDown={(e) => {
                                if (e.key === 'Enter' && !e.shiftKey) {
                                    e.preventDefault();
                                    sendMessage();
                                }
                            }}
                            rows={1}
                        />
                        <Button
                            onClick={sendMessage}
                            className="bg-blue-500 text-white rounded-md p-3 hover:bg-blue-600"
                            disabled={!currentMessage.trim()}
                            aria-label="Enviar Mensaje"
                        >
                            <Send className="w-6 h-6" />
                        </Button>
                    </div>
                </div>

                {/* Speech to Text */}
                <div className="bg-gray-800 p-6 rounded-lg border border-gray-700">
                    <h2 className="text-2xl font-bold mb-4">Dictado de Voz</h2>
                    <div className="flex items-center gap-4">
                        <Button
                            onClick={toggleSpeechRecognition}
                            className={cn(
                                "rounded-full p-4 transition-colors",
                                isListening
                                    ? "bg-red-600 text-white hover:bg-red-700"
                                    : "bg-blue-600 text-white hover:bg-blue-700"
                            )}
                            aria-label={isListening ? "Detener Dictado" : "Iniciar Dictado"}
                        >
                            {isListening ? (
                                <StopCircle className="w-8 h-8" />
                            ) : (
                                <Mic className="w-8 h-8" />
                            )}
                        </Button>
                        <div className="flex-1">
                            <Textarea
                                value={currentMessage}
                                onChange={(e) => setCurrentMessage(e.target.value)}
                                placeholder="Habla para escribir..."
                                className="w-full bg-gray-700 text-white rounded-md p-3 border border-gray-600 focus:outline-none focus:ring-2 focus:ring-blue-500 resize-none"
                                rows={1}
                                ref={chatInputRef}
                                onKeyDown={(e) => {
                                    if (e.key === 'Enter') {
                                        e.preventDefault();
                                    }
                                }}
                            />
                        </div>
                        {isListening && (
                            <motion.div
                                initial={{ opacity: 0 }}
                                animate={{ opacity: 1 }}
                                transition={{ duration: 0.5, repeat: Infinity, repeatType: 'reverse' }}
                                className="animate-pulse text-red-500"
                            >
                                Escuchando...
                            </motion.div>
                        )}
                    </div>
                </div>
            </main>

            {/* Advertencia */}
            <footer className="bg-yellow-800 text-black p-4 text-center border-t border-yellow-700 flex items-center justify-center gap-2">
                <AlertTriangle className="w-5 h-5" />
                <span className="text-sm">
                    Esta aplicación es una simulación y no es para uso en producción real.  El audio se reproduce a través del altavoz del dispositivo.
                </span>
            </footer>
        </div>
    );
};

export default AndroidWalkieTalkie;

